"""
Custom User model for the LogBook system.
"""
import uuid
import secrets
import hashlib
from datetime import timedelta

from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.db import models
from django.utils import timezone


class UserRole(models.TextChoices):
    """User role choices."""
    SUPER_ADMIN = 'super_admin', 'Super Admin'
    MANAGER = 'manager', 'Manager'
    SUPERVISOR = 'supervisor', 'Supervisor'
    OPERATOR = 'operator', 'Operator'
    CLIENT = 'client', 'Client'


class UserManager(BaseUserManager):
    """Custom user manager."""
    
    def get_queryset(self):
        """Return queryset excluding soft-deleted users by default."""
        return super().get_queryset().filter(is_deleted=False)
    
    def create_user(self, email, password=None, **extra_fields):
        """Create and return a regular user with email and password."""
        if not email:
            raise ValueError('The Email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user
    
    def create_superuser(self, email, password=None, **extra_fields):
        """Create and return a superuser with email and password."""
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('role', UserRole.SUPER_ADMIN)
        extra_fields.setdefault('is_active', True)
        
        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')
        if extra_fields.get('role') != UserRole.SUPER_ADMIN:
            raise ValueError('Superuser must have role=SUPER_ADMIN.')
        
        return self.create_user(email, password, **extra_fields)
    
    def get_by_natural_key(self, email):
        """Retrieve a user by their natural key (email)."""
        return self.get(email=email)


class User(AbstractBaseUser, PermissionsMixin):
    """
    Custom User model with UUID, email authentication, and role-based access.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField(unique=True, db_index=True)
    name = models.CharField(max_length=255, blank=True, null=True)
    
    # Role and permissions
    role = models.CharField(
        max_length=20,
        choices=UserRole.choices,
        default=UserRole.OPERATOR,
    )
    
    # Status flags
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    
    # Soft delete
    is_deleted = models.BooleanField(default=False)
    deleted_at = models.DateTimeField(null=True, blank=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    objects = UserManager()  # Default manager (excludes soft-deleted)
    all_objects = models.Manager()  # Manager that includes all users
    
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []
    
    class Meta:
        db_table = 'users'
        verbose_name = 'User'
        verbose_name_plural = 'Users'
        ordering = ['-created_at']
    
    def __str__(self):
        return self.email
    
    def natural_key(self):
        """Return the natural key for the user (email)."""
        return (self.email,)
    
    def soft_delete(self):
        """Soft delete the user."""
        self.is_deleted = True
        self.deleted_at = timezone.now()
        self.is_active = False
        self.save()
    
    def restore(self):
        """Restore a soft-deleted user."""
        self.is_deleted = False
        self.deleted_at = None
        self.is_active = True
        self.save()
    
    @property
    def is_super_admin(self):
        """Check if user is Super Admin."""
        return self.role == UserRole.SUPER_ADMIN
    
    @property
    def is_manager(self):
        """Check if user is Manager."""
        return self.role == UserRole.MANAGER
    
    @property
    def is_supervisor(self):
        """Check if user is Supervisor."""
        return self.role == UserRole.SUPERVISOR
    
    @property
    def is_operator(self):
        """Check if user is Operator."""
        return self.role == UserRole.OPERATOR
    
    @property
    def is_client(self):
        """Check if user is Client."""
        return self.role == UserRole.CLIENT


def hash_reset_token(raw_token: str) -> str:
    """
    Return a SHA-256 hex digest for a raw reset token.

    The raw token is only sent to the user via email and never stored.
    """
    return hashlib.sha256(raw_token.encode("utf-8")).hexdigest()


class PasswordResetToken(models.Model):
    """
    Password reset token for a user.

    Tokens are single-use and time-limited. Only a hash of the token is stored.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="password_reset_tokens")
    token_hash = models.CharField(max_length=64, db_index=True)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    is_used = models.BooleanField(default=False)

    class Meta:
        db_table = "password_reset_tokens"
        ordering = ["-created_at"]

    def __str__(self) -> str:  # pragma: no cover - trivial
        return f"Password reset token for {self.user.email}"

    @property
    def is_expired(self) -> bool:
        return timezone.now() >= self.expires_at

    def mark_used(self) -> None:
        self.is_used = True
        self.save(update_fields=["is_used"])

    @classmethod
    def create_for_user(cls, user, *, minutes_valid: int = 15):
        """
        Create a new token for the given user, invalidating existing unused ones.

        Returns a tuple of (instance, raw_token) where raw_token is suitable
        for inclusion in an email link.
        """
        cls.objects.filter(user=user, is_used=False).delete()

        raw_token = secrets.token_urlsafe(32)
        token_hash = hash_reset_token(raw_token)
        now = timezone.now()
        expires_at = now + timedelta(minutes=minutes_valid)

        instance = cls.objects.create(
            user=user,
            token_hash=token_hash,
            expires_at=expires_at,
        )
        return instance, raw_token

